// prisma/schema.prisma

generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

// ===== Enums =====
enum MatchStatus {
  PENDING        // Esperando fecha
  DATE_PROPOSED  // Fecha propuesta, esperando confirmación
  SCHEDULED      // Fecha confirmada
  IN_PROGRESS    // En juego
  COMPLETED      // Terminado
  CANCELLED      // Cancelado
}

enum GroupStatus {
  PENDING
  IN_PROGRESS
  PLAYED
  SKIPPED
  POSTPONED
}

// ===== Models =====
model User {
  id              String   @id @default(cuid())
  name            String
  email           String   @unique
  password        String
  isAdmin         Boolean  @default(false)
  createdAt       DateTime @default(now())
  updatedAt       DateTime @updatedAt

  // Relaciones
  player          Player?
  proposedMatches Match[]  @relation("MatchProposer")

  @@map("users")

  // INDEXES CRÍTICOS
  @@index([email])
  @@index([isAdmin])
}

model Tournament {
  id                String             @id @default(cuid())
  title             String
  startDate         DateTime
  endDate           DateTime
  totalRounds       Int
  roundDurationDays Int
  isActive          Boolean            @default(true)
  isPublic          Boolean            @default(true)
  createdAt         DateTime           @default(now())
  updatedAt         DateTime           @updatedAt

  // Relaciones
  rounds            Round[]
  players           TournamentPlayer[]

  // Configuración de comodines
  maxComodinesPerPlayer    Int     @default(1)
  enableMeanComodin        Boolean @default(true)
  enableSubstituteComodin  Boolean @default(true)

  // Configuración suplente
  substituteCreditFactor   Float   @default(0.5) // 50% del puntaje del titular
  substituteMaxAppearances Int     @default(2)   // máximo por torneo

  // CONTINUIDAD (renombrado de streak*)
  continuityEnabled        Boolean @default(true)
  continuityPointsPerSet   Float   @default(1.0)
  continuityPointsPerRound Float   @default(3.0)
  continuityMinRounds      Int     @default(2)
  continuityMaxBonus       Float   @default(9.0)
  continuityMode           String  @default("MATCHES") // "SETS" | "MATCHES" | "BOTH"

  @@map("tournaments")

  // INDEXES CRÍTICOS
  @@index([isActive])
  @@index([startDate, endDate])
}

model Player {
  id           String             @id @default(cuid())
  userId       String             @unique
  name         String

  // Relaciones
  groupPlayers GroupPlayer[]
  matchResults MatchResult[]
  user         User               @relation(fields: [userId], references: [id], onDelete: Cascade)
  tournaments  TournamentPlayer[]
  streaks      StreakHistory[]
  notificationsReadAt DateTime? @db.Timestamptz

  @@map("players")
}

model TournamentPlayer {
  id                    String @id @default(cuid())
  tournamentId          String
  playerId              String
  joinedRound           Int    @default(1)
  comodinesUsed         Int    @default(0)
  substituteAppearances Int    @default(0)

  // Relaciones
  player     Player     @relation(fields: [playerId], references: [id], onDelete: Cascade)
  tournament Tournament @relation(fields: [tournamentId], references: [id], onDelete: Cascade)

  @@unique([tournamentId, playerId])
  @@map("tournament_players")
}

model Round {
  id           String     @id @default(cuid())
  tournamentId String
  number       Int
  startDate    DateTime
  endDate      DateTime
  isClosed     Boolean    @default(false)
  createdAt    DateTime   @default(now())
  updatedAt    DateTime   @updatedAt

  // Relaciones
  groups       Group[]
  tournament   Tournament @relation(fields: [tournamentId], references: [id], onDelete: Cascade)
  streaks      StreakHistory[]

  @@unique([tournamentId, number])
  @@map("rounds")

  // INDEXES CRÍTICOS
  @@index([tournamentId, number])
  @@index([isClosed])
}

model Group {
  id      String        @id @default(cuid())
  roundId String
  number  Int
  level   Int
  
  // ✅ NUEVO: Estado del grupo y gestión de no disputados
  status        GroupStatus @default(PENDING)
  skippedReason String?
  graceEndAt    DateTime?

  // Relaciones
  players GroupPlayer[]
  matches Match[]
  round   Round         @relation(fields: [roundId], references: [id], onDelete: Cascade)
  streaks StreakHistory[]

  @@unique([roundId, number])
  @@map("groups")
}

model GroupPlayer {
  id                 String    @id @default(cuid())
  groupId            String
  playerId           String
  position           Int
  points             Float     @default(0)
  streak             Int       @default(0)
  usedComodin        Boolean   @default(false)
  comodinReason      String?   @db.Text
  comodinAt          DateTime?
  substitutePlayerId String?
  
  // ✅ NUEVO: Bloqueo para movimientos de escalera
  locked             Boolean   @default(false)

  // Relaciones
  group  Group  @relation(fields: [groupId], references: [id], onDelete: Cascade)
  player Player @relation(fields: [playerId], references: [id], onDelete: Cascade)

  @@unique([groupId, playerId])
  @@unique([groupId, position])
  @@map("group_players")

  // INDEXES CRÍTICOS
  @@index([playerId])
  @@index([groupId, points])
}

model Match {
  id             String @id @default(cuid())
  groupId        String
  setNumber      Int
  team1Player1Id String
  team1Player2Id String
  team2Player1Id String
  team2Player2Id String

  // Resultado
  team1Games    Int?
  team2Games    Int?
  tiebreakScore String?
  isConfirmed   Boolean @default(false)
  reportedById  String?
  confirmedById String?
  photoUrl      String?

  // Fechas / estado
  proposedDate DateTime?
  proposedById String?
  acceptedDate DateTime?
  acceptedBy   String[]     // Pg: lista de confirmadores
  status       MatchStatus  @default(PENDING)

  // Relaciones
  group    Group @relation(fields: [groupId], references: [id], onDelete: Cascade)
  proposer User? @relation("MatchProposer", fields: [proposedById], references: [id])

  // Tracking de disputas
  disputedBy     String?
  disputedAt     DateTime?
  disputeReason  String?

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@unique([groupId, setNumber])
  @@map("matches")

  // INDEXES CRÍTICOS
  @@index([groupId, status])
  @@index([isConfirmed])
}

model MatchResult {
  id       String  @id @default(cuid())
  matchId  String
  playerId String
  games    Int
  sets     Int
  points   Float
  isWinner Boolean

  // Relaciones
  player   Player  @relation(fields: [playerId], references: [id], onDelete: Cascade)

  @@unique([matchId, playerId])
  @@map("match_results")
}

model Ranking {
  id              String @id @default(cuid())
  tournamentId    String
  playerId        String
  roundNumber     Int
  totalPoints     Float
  roundsPlayed    Int
  averagePoints   Float
  position        Int
  ironmanPosition Int
  movement        String

  @@unique([tournamentId, playerId, roundNumber])
  @@map("rankings")
}

// Historial de "rachas/continuidad"
model StreakHistory {
  id          String   @id @default(cuid())
  playerId    String
  roundId     String
  groupId     String
  streakType  String   // "SET_WIN", "MATCH_WIN", "POSITION_WIN", "CONTINUITY_BONUS", "BROKEN_NO_PLAY"
  streakCount Int
  bonusPoints Float
  createdAt   DateTime @default(now())

  // Relaciones
  player Player @relation(fields: [playerId], references: [id], onDelete: Cascade)
  round  Round  @relation(fields: [roundId], references: [id], onDelete: Cascade)
  group  Group  @relation(fields: [groupId], references: [id], onDelete: Cascade)

  @@map("streak_history")
}