generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

// Definir ENUM primero
enum MatchStatus {
  PENDING // Esperando fecha
  DATE_PROPOSED // Fecha propuesta, esperando confirmación  
  SCHEDULED // Fecha confirmada
  IN_PROGRESS // En juego
  COMPLETED // Terminado
  CANCELLED // Cancelado
}

model User {
  id              String   @id @default(cuid())
  name            String
  email           String   @unique
  password        String
  isAdmin         Boolean  @default(false)
  createdAt       DateTime @default(now())
  updatedAt       DateTime @updatedAt
  player          Player?
  proposedMatches Match[]  @relation("MatchProposer")

  @@map("users")
}

model Tournament {
  id                String             @id @default(cuid())
  title             String
  startDate         DateTime
  endDate           DateTime
  totalRounds       Int
  roundDurationDays Int
  isActive          Boolean            @default(true)
  isPublic          Boolean            @default(true)
  createdAt         DateTime           @default(now())
  updatedAt         DateTime           @updatedAt
  rounds            Round[]
  players           TournamentPlayer[]

  // CAMPOS AÑADIDOS: configuración para créditos de suplente
  substituteCreditFactor   Float @default(0.5) // 50% del puntaje del titular
  substituteMaxAppearances Int   @default(2)   // máximo de veces que alguien puede ser suplente por torneo

  @@map("tournaments")
}

model Player {
  id           String             @id @default(cuid())
  userId       String             @unique
  name         String
  groupPlayers GroupPlayer[]
  matchResults MatchResult[]
  user         User               @relation(fields: [userId], references: [id], onDelete: Cascade)
  tournaments  TournamentPlayer[]

  @@map("players")
}

model TournamentPlayer {
  id            String @id @default(cuid())
  tournamentId  String
  playerId      String
  joinedRound   Int    @default(1)
  comodinesUsed Int    @default(0)

  // CAMPO AÑADIDO: para limitar cuántas veces actuó de suplente en ese torneo
  substituteAppearances Int @default(0)

  player     Player     @relation(fields: [playerId], references: [id], onDelete: Cascade)
  tournament Tournament @relation(fields: [tournamentId], references: [id], onDelete: Cascade)

  @@unique([tournamentId, playerId])
  @@map("tournament_players")
}

model Round {
  id           String     @id @default(cuid())
  tournamentId String
  number       Int
  startDate    DateTime
  endDate      DateTime
  isClosed     Boolean    @default(false)
  createdAt    DateTime   @default(now())
  groups       Group[]
  tournament   Tournament @relation(fields: [tournamentId], references: [id], onDelete: Cascade)

  @@unique([tournamentId, number])
  @@map("rounds")
}

model Group {
  id      String        @id @default(cuid())
  roundId String
  number  Int
  level   Int
  players GroupPlayer[]
  matches Match[]
  round   Round         @relation(fields: [roundId], references: [id], onDelete: Cascade)

  @@unique([roundId, number])
  @@map("groups")
}

model GroupPlayer {
  id            String    @id @default(cuid())
  groupId       String
  playerId      String
  position      Int
  points        Float     @default(0)
  streak        Int       @default(0)
  usedComodin   Boolean   @default(false)
  comodinReason String?   @db.Text
  comodinAt     DateTime?

  // CAMPO AÑADIDO: si hubo comodín "suplente", quién jugó por mí en esta ronda
  substitutePlayerId String?

  group  Group  @relation(fields: [groupId], references: [id], onDelete: Cascade)
  player Player @relation(fields: [playerId], references: [id], onDelete: Cascade)

  @@unique([groupId, playerId])
  @@unique([groupId, position])
  @@map("group_players")
}

model Match {
  id             String @id @default(cuid())
  groupId        String
  setNumber      Int
  team1Player1Id String
  team1Player2Id String
  team2Player1Id String
  team2Player2Id String

  // Campos existentes de resultados
  team1Games    Int?
  team2Games    Int?
  tiebreakScore String?
  isConfirmed   Boolean @default(false)
  reportedById  String?
  confirmedById String?
  photoUrl      String?

  // CAMPOS para gestión de fechas
  proposedDate DateTime?
  proposedById String?
  acceptedDate DateTime?
  acceptedBy   String[]
  status       MatchStatus @default(PENDING)

  // Relaciones
  group    Group @relation(fields: [groupId], references: [id], onDelete: Cascade)
  proposer User? @relation("MatchProposer", fields: [proposedById], references: [id])

  createdAt DateTime @default(now())
  updatedAt DateTime @default(now()) @updatedAt

  @@unique([groupId, setNumber])
  @@map("matches")
}

model MatchResult {
  id       String  @id @default(cuid())
  matchId  String
  playerId String
  games    Int
  sets     Int
  points   Float
  isWinner Boolean
  player   Player  @relation(fields: [playerId], references: [id], onDelete: Cascade)

  @@unique([matchId, playerId])
  @@map("match_results")
}

model Ranking {
  id              String @id @default(cuid())
  tournamentId    String
  playerId        String
  roundNumber     Int
  totalPoints     Float
  roundsPlayed    Int
  averagePoints   Float
  position        Int
  ironmanPosition Int
  movement        String

  @@unique([tournamentId, playerId, roundNumber])
  @@map("rankings")
}